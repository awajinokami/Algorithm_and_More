# Trie树



# 并查集

## 性质

复杂度近乎O(1)

用树维护所有元素，根节点编号是集合编号，对每个点存储父节点p(x)


## 支持的操作

1. 将两个集合合并

2. 询问两个元素是否在一个集合当中

## 相关问题

1. 判断树根：p(x)=x

2. 如何求x的集合编号 while(p(x)!=x)x=p(x)
	
3. 如何合并两个集合 : px是x的集合编号，py是y的集合编号，则让px=y

4. (扩充问题)统计集合大小：加一个size数组，保证只有根节点的size有意义，合并两棵树的时候需要更新

## 优化

1. 路径压缩：查到祖先之后就把px存成祖先，写在find函数里

2. 按秩合并：合并的时候小树接在大树后面，一般不考

## 其他

scanf读字母最好写成string，避免读入空格


# 堆

## 性质

堆是一颗完全二叉树（很平衡，除了最后一层结点，其他都是满的）

小根堆：每个点是最小值，每个点都小于等于两个儿子

存储：用一维数组存树，x的左儿子是2x，x的右儿子是2x+1, 从1开始计算


## 支持的操作

1. 插入一个数： 
	- 插入最后，再不断往上移动
	- heap[++size]=x, up(size)

2. 求集合当中最小值: 
	- heap[1] （从1计数）

3. 删除最小值：
	- healp[1]=heap[size];size--;down(1) 
	- 分三步，把第一个替换成最下面的一个，改size，把第一个往下沉

4. 删除任意元素--STL不支持
	- heap[k]=heap[size];size--;down(k);up(k);
	- 只有变大会往下，只有变小会网上，所以两个都写但只会执行一个

5. 修改任意元素--STL不支持
	- heap[k]=x; down(k);up(k);


## 两个基本操作，再组合成上面的操作

	- up(x)：把一个结点往上移动，每次只和根节点作比较（因为另外一个有序）

	- down(x)：把一个结点往下移动

	- 复杂度O(log N): 树的高度

## 堆的初始化
	- 时间复杂度 O(n): 计算题，倒数第二层的最多降一层
	- 空间复杂度 O(1)




